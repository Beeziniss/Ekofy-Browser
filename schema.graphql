schema {
  query: QueryInitialization
  mutation: MutationInitialization
}

"""
The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response.
"""
directive @cost(
  """
  The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc.
  """
  weight: String!
) on ARGUMENT_DEFINITION | ENUM | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | OBJECT | SCALAR

"""
The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information.
"""
directive @listSize(
  """
  The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field.
  """
  assumedSize: Int
  """
  The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error.
  """
  requireOneSlicingArgument: Boolean! = true
  """
  The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields.
  """
  sizedFields: [String!]
  """
  The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query.
  """
  slicingArgumentDefaultValue: Int
  """
  The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments.
  """
  slicingArguments: [String!]
) on FIELD_DEFINITION

type AccountLinkResponse {
  accountId: String!
  created: DateTime!
  expired: DateTime!
  refreshUrl: String!
  returnUrl: String!
  type: String!
  url: String!
}

type Address {
  addressLine: String
  oldDistrict: String
  oldProvince: String
  oldWard: String
  province: String
  street: String
  ward: String
}

input AddressFilterInput {
  addressLine: StringOperationFilterInput
  and: [AddressFilterInput!]
  oldDistrict: StringOperationFilterInput
  oldProvince: StringOperationFilterInput
  oldWard: StringOperationFilterInput
  or: [AddressFilterInput!]
  province: StringOperationFilterInput
  street: StringOperationFilterInput
  ward: StringOperationFilterInput
}

input AddressInput {
  addressLine: String
  oldDistrict: String
  oldProvince: String
  oldWard: String
  province: String
  street: String
  ward: String
}

input AddressSortInput {
  addressLine: SortEnumType
  oldDistrict: SortEnumType
  oldProvince: SortEnumType
  oldWard: SortEnumType
  province: SortEnumType
  street: SortEnumType
  ward: SortEnumType
}

enum AggregationLevel {
  FULL
  NONE
  RECORDING
  WORK
}

input AggregationLevelOperationFilterInput {
  eq: AggregationLevel
  in: [AggregationLevel!]
  neq: AggregationLevel
  nin: [AggregationLevel!]
}

enum AlbumType {
  ALBUM
  COMPILATION
  EP
  LIVE
  REMIX
  SINGLE
  SOUNDTRACK
}

"""Defines when a policy shall be executed."""
enum ApplyPolicy {
  """After the resolver was executed."""
  AFTER_RESOLVER
  """Before the resolver was executed."""
  BEFORE_RESOLVER
  """The policy is applied in the validation step before the execution."""
  VALIDATION
}

type Artist {
  artistType: ArtistType!
  avatarImage: String
  bannerImage: String
  biography: String
  categories: [Category]!
  categoryIds: [String!]!
  createdAt: DateTime!
  email: String!
  followerCount: Long!
  id: String!
  identityCard: IdentityCard!
  isVerified: Boolean!
  legalDocuments: [LegalDocument!]!
  members: [ArtistMember!]!
  popularity: Long!
  restriction: Restriction!
  stageName: String!
  updatedAt: DateTime
  user: User!
  userId: String!
  verifiedAt: DateTime
}

input ArtistFilterInput {
  and: [ArtistFilterInput!]
  artistType: ArtistTypeOperationFilterInput
  avatarImage: StringOperationFilterInput
  bannerImage: StringOperationFilterInput
  biography: StringOperationFilterInput
  categoryIds: ListStringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  email: StringOperationFilterInput
  followerCount: LongOperationFilterInput
  id: StringOperationFilterInput
  identityCard: IdentityCardFilterInput
  isVerified: BooleanOperationFilterInput
  legalDocuments: ListFilterInputTypeOfLegalDocumentFilterInput
  members: ListFilterInputTypeOfArtistMemberFilterInput
  or: [ArtistFilterInput!]
  popularity: LongOperationFilterInput
  restriction: RestrictionFilterInput
  stageName: StringOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  userId: StringOperationFilterInput
  verifiedAt: DateTimeOperationFilterInput
}

type ArtistMember {
  email: String!
  fullName: String!
  gender: UserGender!
  isLeader: Boolean!
  phoneNumber: String!
}

input ArtistMemberFilterInput {
  and: [ArtistMemberFilterInput!]
  email: StringOperationFilterInput
  fullName: StringOperationFilterInput
  gender: UserGenderOperationFilterInput
  isLeader: BooleanOperationFilterInput
  or: [ArtistMemberFilterInput!]
  phoneNumber: StringOperationFilterInput
}

type ArtistPackage {
  amount: Decimal!
  createdAt: DateTime!
  currency: CurrencyType!
  description: String
  estimateDeliveryDays: Int!
  id: String!
  packageName: String!
  serviceDetails: [Metadata!]!
  status: ArtistPackageStatus!
  updatedAt: DateTime
  version: Long!
}

input ArtistPackageFilterInput {
  amount: DecimalOperationFilterInput
  and: [ArtistPackageFilterInput!]
  createdAt: DateTimeOperationFilterInput
  currency: CurrencyTypeOperationFilterInput
  description: StringOperationFilterInput
  estimateDeliveryDays: IntOperationFilterInput
  id: StringOperationFilterInput
  or: [ArtistPackageFilterInput!]
  packageName: StringOperationFilterInput
  serviceDetails: ListFilterInputTypeOfMetadataFilterInput
  status: ArtistPackageStatusOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  version: LongOperationFilterInput
}

input ArtistPackageSortInput {
  amount: SortEnumType
  createdAt: SortEnumType
  currency: SortEnumType
  description: SortEnumType
  estimateDeliveryDays: SortEnumType
  id: SortEnumType
  packageName: SortEnumType
  status: SortEnumType
  updatedAt: SortEnumType
  version: SortEnumType
}

enum ArtistPackageStatus {
  CANCELED
  DISABLED
  ENABLED
  PENDING
  REJECTED
}

input ArtistPackageStatusOperationFilterInput {
  eq: ArtistPackageStatus
  in: [ArtistPackageStatus!]
  neq: ArtistPackageStatus
  nin: [ArtistPackageStatus!]
}

"""A segment of a collection."""
type ArtistPackagesCollectionSegment {
  """A flattened list of the items."""
  items: [ArtistPackage!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ArtistRegistrationApprovalRequestInput {
  email: String!
  fullName: String!
  rejectionReason: String
  userId: String!
}

enum ArtistRole {
  COMPOSER
  FEATURED
  MAIN
  REMIXER
}

input ArtistRoleOperationFilterInput {
  eq: ArtistRole
  in: [ArtistRole!]
  neq: ArtistRole
  nin: [ArtistRole!]
}

input ArtistSortInput {
  artistType: SortEnumType
  avatarImage: SortEnumType
  bannerImage: SortEnumType
  biography: SortEnumType
  createdAt: SortEnumType
  email: SortEnumType
  followerCount: SortEnumType
  id: SortEnumType
  identityCard: IdentityCardSortInput
  isVerified: SortEnumType
  popularity: SortEnumType
  restriction: RestrictionSortInput
  stageName: SortEnumType
  updatedAt: SortEnumType
  userId: SortEnumType
  verifiedAt: SortEnumType
}

enum ArtistType {
  BAND
  GROUP
  INDIVIDUAL
}

input ArtistTypeOperationFilterInput {
  eq: ArtistType
  in: [ArtistType!]
  neq: ArtistType
  nin: [ArtistType!]
}

"""A segment of a collection."""
type ArtistsCollectionSegment {
  """A flattened list of the items."""
  items: [Artist!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type AudioFeature {
  acousticness: Float!
  chromaMean: [Float!]!
  danceability: Float!
  duration: Float!
  energy: Float!
  key: String!
  keyNumber: Int!
  mfccMean: [Float!]!
  mode: String!
  modeNumber: Int!
  spectralCentroid: Float!
  tempo: Float!
  zeroCrossingRate: Float!
}

input AudioFeatureFilterInput {
  acousticness: FloatOperationFilterInput
  and: [AudioFeatureFilterInput!]
  chromaMean: ListFloatOperationFilterInput
  danceability: FloatOperationFilterInput
  duration: FloatOperationFilterInput
  energy: FloatOperationFilterInput
  key: StringOperationFilterInput
  keyNumber: IntOperationFilterInput
  mfccMean: ListFloatOperationFilterInput
  mode: StringOperationFilterInput
  modeNumber: IntOperationFilterInput
  or: [AudioFeatureFilterInput!]
  spectralCentroid: FloatOperationFilterInput
  tempo: FloatOperationFilterInput
  zeroCrossingRate: FloatOperationFilterInput
}

input AudioFeatureSortInput {
  acousticness: SortEnumType
  danceability: SortEnumType
  duration: SortEnumType
  energy: SortEnumType
  key: SortEnumType
  keyNumber: SortEnumType
  mode: SortEnumType
  modeNumber: SortEnumType
  spectralCentroid: SortEnumType
  tempo: SortEnumType
  zeroCrossingRate: SortEnumType
}

type AudioFingerprint {
  compressedFingerprints: [[Byte!]!]!
  createdAt: DateTime!
  duration: Float!
  originalPoints: [[Byte!]!]!
  sequenceNumbers: [UInt32!]!
  startsAt: [Float!]!
  updatedAt: DateTime
}

input AudioFingerprintFilterInput {
  and: [AudioFingerprintFilterInput!]
  compressedFingerprints: ListListByteOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  duration: FloatOperationFilterInput
  or: [AudioFingerprintFilterInput!]
  originalPoints: ListListByteOperationFilterInput
  sequenceNumbers: ListOfUInt32FilterInput
  startsAt: ListFloatOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input AudioFingerprintSortInput {
  createdAt: SortEnumType
  duration: SortEnumType
  updatedAt: SortEnumType
}

enum AudioFormat {
  MP3
  WAV
}

enum BillingPortalConfigStatus {
  ACTIVE
  DEPRECATED
  INACTIVE
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

"""
The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255.
"""
scalar Byte

input ByteOperationFilterInput {
  eq: Byte
  gt: Byte
  gte: Byte
  in: [Byte]
  lt: Byte
  lte: Byte
  neq: Byte
  ngt: Byte
  ngte: Byte
  nin: [Byte]
  nlt: Byte
  nlte: Byte
}

"""A segment of a collection."""
type CategoriesCollectionSegment {
  """A flattened list of the items."""
  items: [Category!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type Category {
  aliases: [String!]!
  createdAt: DateTime!
  description: String
  id: String!
  isVisible: Boolean!
  name: String!
  popularity: Int!
  slug: String!
  type: CategoryType!
  updatedAt: DateTime
}

input CategoryFilterInput {
  aliases: ListStringOperationFilterInput
  and: [CategoryFilterInput!]
  createdAt: DateTimeOperationFilterInput
  description: StringOperationFilterInput
  id: StringOperationFilterInput
  isVisible: BooleanOperationFilterInput
  name: StringOperationFilterInput
  or: [CategoryFilterInput!]
  popularity: IntOperationFilterInput
  slug: StringOperationFilterInput
  type: CategoryTypeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

input CategorySortInput {
  createdAt: SortEnumType
  description: SortEnumType
  id: SortEnumType
  isVisible: SortEnumType
  name: SortEnumType
  popularity: SortEnumType
  slug: SortEnumType
  type: SortEnumType
  updatedAt: SortEnumType
}

enum CategoryType {
  GENRE
  MOOD
}

input CategoryTypeOperationFilterInput {
  eq: CategoryType
  in: [CategoryType!]
  neq: CategoryType
  nin: [CategoryType!]
}

type CheckoutSessionResponse {
  cancelUrl: String!
  created: DateTime!
  expired: DateTime!
  id: String!
  mode: String!
  status: String!
  successUrl: String!
  url: String!
}

"""Information about the offset pagination."""
type CollectionSegmentInfo {
  """
  Indicates whether more items exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!
  """
  Indicates whether more items exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!
}

input CommentRepliesRequestInput {
  commentId: String!
  page: Int!
  pageSize: Int!
  sortOrder: CommentSortOrder!
}

type CommentRepliesResponse {
  hasNextPage: Boolean!
  page: Int!
  pageSize: Int!
  parentCommentId: String!
  replies: [TrackCommentResponse!]!
  totalReplies: Int!
}

enum CommentSortOrder {
  CHRONOLOGICAL
  POPULARITY_BASED
  REVERSE_CHRONOLOGICAL
  THREAD_ACTIVITY
}

type CommentThread {
  hasMoreReplies: Boolean!
  lastActivity: DateTime!
  replies: [TrackCommentResponse!]!
  rootComment: TrackCommentResponse!
  totalReplies: Int!
}

"""A segment of a collection."""
type CommentThreadCollectionSegment {
  """A flattened list of the items."""
  items: [TrackCommentResponse!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CommentThreadRequestInput {
  commentId: String!
  includeDeleted: Boolean!
}

type Coupon {
  code: String!
  createdAt: DateTime!
  description: String
  duration: CouponDurationType!
  id: String!
  name: String!
  percentOff: Decimal!
  purpose: CouponPurposeType!
  status: CouponStatus!
  stripeCouponId: String!
  updatedAt: DateTime
}

enum CouponDurationType {
  FOREVER
  ONCE
  REPEATING
}

input CouponDurationTypeOperationFilterInput {
  eq: CouponDurationType
  in: [CouponDurationType!]
  neq: CouponDurationType
  nin: [CouponDurationType!]
}

input CouponFilterInput {
  and: [CouponFilterInput!]
  code: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  description: StringOperationFilterInput
  duration: CouponDurationTypeOperationFilterInput
  id: StringOperationFilterInput
  name: StringOperationFilterInput
  or: [CouponFilterInput!]
  percentOff: DecimalOperationFilterInput
  purpose: CouponPurposeTypeOperationFilterInput
  status: CouponStatusOperationFilterInput
  stripeCouponId: StringOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
}

enum CouponPurposeType {
  ANNUAL_PLAN_DISCOUNT
  AUTO_SERVICE
  GENERAL
}

input CouponPurposeTypeOperationFilterInput {
  eq: CouponPurposeType
  in: [CouponPurposeType!]
  neq: CouponPurposeType
  nin: [CouponPurposeType!]
}

input CouponSortInput {
  code: SortEnumType
  createdAt: SortEnumType
  description: SortEnumType
  duration: SortEnumType
  id: SortEnumType
  name: SortEnumType
  percentOff: SortEnumType
  purpose: SortEnumType
  status: SortEnumType
  stripeCouponId: SortEnumType
  updatedAt: SortEnumType
}

enum CouponStatus {
  ACTIVE
  DEPRECATED
  EXPIRED
  INACTIVE
}

input CouponStatusOperationFilterInput {
  eq: CouponStatus
  in: [CouponStatus!]
  neq: CouponStatus
  nin: [CouponStatus!]
}

"""A segment of a collection."""
type CouponsCollectionSegment {
  """A flattened list of the items."""
  items: [Coupon!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CreateAdminRequestInput {
  email: String!
  password: String!
}

input CreateArtistPackageRequestInput {
  amount: Decimal!
  description: String
  estimateDeliveryDays: Int!
  packageName: String!
  serviceDetails: [MetadataInput!]!
}

input CreateArtistRequestInput {
  biography: String!
  identityCard: IdentityCardInput!
  name: String!
  userId: String!
}

input CreateBillingPortalConfigurationRequestInput {
  allowedCustomerUpdates: [CustomerUpdate!]!
  allowedSubscriptionUpdates: [StripeSubscriptionUpdate!]!
  customerUpdateEnabled: Boolean!
  invoiceHistoryEnabled: Boolean!
  mode: StripeSubscriptionCancelMode!
  paymentMethodUpdateEnabled: Boolean!
  products: [StripeProductRequestInput!]!
  status: BillingPortalConfigStatus!
  subscriptionCancelEnabled: Boolean!
  subscriptionTier: SubscriptionTier!
  subscriptionVersion: Long!
  suscriptionUpdateEnabled: Boolean!
  userRole: UserRole!
  version: Long!
}

input CreateCategoryRequestInput {
  description: String!
  name: String!
  type: CategoryType!
}

input CreateCouponRequestInput {
  code: String!
  description: String
  duration: CouponDurationType!
  name: String!
  percentOff: Decimal!
  purpose: CouponPurposeType!
  status: CouponStatus!
}

input CreateEntitlementRequestInput {
  code: String!
  defaultValues: EntitlementValue!
  description: String!
  isActive: Boolean!
  name: String!
  subscriptionOverrides: [CreateEntitlementSubscriptionOverrideRequestInput!]!
  valueType: EntitlementValueType!
}

input CreateEntitlementSubscriptionOverrideRequestInput {
  subscriptionCode: String!
}

input CreateLegalPolicyRequestInput {
  content: String!
  isActive: Boolean!
  name: String!
}

input CreateModeratorRequestInput {
  email: String!
  password: String!
}

input CreateMomoPaymentRequestInput {
  amount: Long!
  orderId: String!
  orderInfo: String!
}

input CreatePaymentCheckoutSessionRequestInput {
  cancelUrl: String!
  isReceiptEmail: Boolean!
  isSavePaymentMethod: Boolean!
  packageId: String!
  successUrl: String!
}

input CreatePriceRequestInput {
  interval: PeriodTime!
  intervalCount: Long!
  lookupKey: String!
}

input CreateRecordingRequestInput {
  description: String
  recordingSplits: [CreateRecordingSplitRequestInput!]!
}

type CreateRecordingSplitRequest {
  artistRole: ArtistRole!
  percentage: Decimal!
  userId: String!
}

input CreateRecordingSplitRequestInput {
  artistRole: ArtistRole!
  percentage: Decimal!
  userId: String!
}

input CreateRoyalPolicyRequestInput {
  currency: CurrencyType!
  effectiveAt: DateTime!
  ratePerStream: Decimal!
  recordingPercentage: Decimal!
  workPercentage: Decimal!
}

input CreateSubScriptionPlanRequestInput {
  images: [String!]
  metadata: [KeyValuePairOfStringAndStringInput!]
  name: String!
  prices: [CreatePriceRequestInput!]!
  subscriptionCode: String!
}

input CreateSubscriptionCheckoutSessionRequestInput {
  cancelUrl: String!
  isSavePaymentMethod: Boolean!
  period: PeriodTime!
  subscriptionCode: String!
  successUrl: String!
}

input CreateSubscriptionRequestInput {
  code: String!
  description: String
  name: String!
  price: Decimal!
  status: SubscriptionStatus!
  tier: SubscriptionTier!
  version: Int!
}

input CreateTrackCommentRequestInput {
  content: String!
  parentCommentId: String
  trackId: String!
}

input CreateTrackRequestInput {
  categoryIds: [String!]!
  coverImage: String!
  description: String
  featuredArtistIds: [String!]!
  isExplicit: Boolean!
  isOriginal: Boolean!
  isReleased: Boolean!
  lyrics: String
  mainArtistIds: [String!]!
  name: String!
  previewVideo: String
  releaseDate: DateTime
  releaseStatus: ReleaseStatus!
  tags: [String!]!
}

input CreateWorkRequestInput {
  description: String
  workSplits: [CreateWorkSplitRequestInput!]!
}

type CreateWorkSplitRequest {
  artistRole: ArtistRole!
  percentage: Decimal!
  userId: String!
}

input CreateWorkSplitRequestInput {
  artistRole: ArtistRole!
  percentage: Decimal!
  userId: String!
}

enum CurrencyType {
  AUD
  CAD
  CHF
  CNY
  EUR
  GBP
  JPY
  NZD
  SEK
  SGD
  SGP
  USD
  VND
}

input CurrencyTypeOperationFilterInput {
  eq: CurrencyType
  in: [CurrencyType!]
  neq: CurrencyType
  nin: [CurrencyType!]
}

enum CustomerUpdate {
  ADDRESS
  EMAIL
  PHONE
  SHIPPING
  TAX_ID
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

input DateTimeOperationFilterInput {
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  neq: DateTime
  ngt: DateTime
  ngte: DateTime
  nin: [DateTime]
  nlt: DateTime
  nlte: DateTime
}

"""The `Decimal` scalar type represents a decimal floating-point number."""
scalar Decimal

input DecimalOperationFilterInput {
  eq: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal]
  lt: Decimal
  lte: Decimal
  neq: Decimal
  ngt: Decimal
  ngte: Decimal
  nin: [Decimal]
  nlt: Decimal
  nlte: Decimal
}

input DeleteTrackCommentRequestInput {
  commentId: String!
}

enum DocumentType {
  CERTIFICATE
  CONTRACT
  LICENSE
  OTHER
}

input DocumentTypeOperationFilterInput {
  eq: DocumentType
  in: [DocumentType!]
  neq: DocumentType
  nin: [DocumentType!]
}

type Entitlement {
  code: String!
  createdAt: DateTime!
  defaultValues: [EntitlementRoleDefault!]!
  description: String!
  expiredAt: DateTime
  id: String!
  isActive: Boolean!
  name: String!
  subscriptionOverrides: [EntitlementSubscriptionOverride!]!
  updatedAt: DateTime
  value: EntitlementValue!
  valueType: EntitlementValueType!
}

input EntitlementFilterInput {
  and: [EntitlementFilterInput!]
  code: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  defaultValues: ListFilterInputTypeOfEntitlementRoleDefaultFilterInput
  description: StringOperationFilterInput
  expiredAt: DateTimeOperationFilterInput
  id: StringOperationFilterInput
  isActive: BooleanOperationFilterInput
  name: StringOperationFilterInput
  or: [EntitlementFilterInput!]
  subscriptionOverrides: ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput
  updatedAt: DateTimeOperationFilterInput
  valueType: EntitlementValueTypeOperationFilterInput
}

type EntitlementRoleDefault {
  role: UserRole!
}

input EntitlementRoleDefaultFilterInput {
  and: [EntitlementRoleDefaultFilterInput!]
  or: [EntitlementRoleDefaultFilterInput!]
  role: UserRoleOperationFilterInput
}

input EntitlementSortInput {
  code: SortEnumType
  createdAt: SortEnumType
  description: SortEnumType
  expiredAt: SortEnumType
  id: SortEnumType
  isActive: SortEnumType
  name: SortEnumType
  updatedAt: SortEnumType
  valueType: SortEnumType
}

type EntitlementSubscriptionOverride {
  subscriptionCode: String!
}

input EntitlementSubscriptionOverrideFilterInput {
  and: [EntitlementSubscriptionOverrideFilterInput!]
  or: [EntitlementSubscriptionOverrideFilterInput!]
  subscriptionCode: StringOperationFilterInput
}

"""
Polymorphic scalar for String, Int, Long, Double, Decimal, Boolean, DateTime, Object, Array.
"""
scalar EntitlementValue

enum EntitlementValueType {
  ARRAY
  BOOLEAN
  DATE_TIME
  DECIMAL
  DOUBLE
  INT
  LONG
  OBJECT
  STRING
}

input EntitlementValueTypeOperationFilterInput {
  eq: EntitlementValueType
  in: [EntitlementValueType!]
  neq: EntitlementValueType
  nin: [EntitlementValueType!]
}

"""A segment of a collection."""
type EntitlementsCollectionSegment {
  """A flattened list of the items."""
  items: [Entitlement!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input FloatOperationFilterInput {
  eq: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  neq: Float
  ngt: Float
  ngte: Float
  nin: [Float]
  nlt: Float
  nlte: Float
}

input FollowUserRequestInput {
  targetUserId: String!
}

type IdentityCard {
  backImage: String
  dateOfBirth: DateTime!
  frontImage: String
  fullName: String!
  gender: UserGender!
  nationality: String!
  number: String!
  placeOfOrigin: String!
  placeOfResidence: Address!
  validUntil: DateTime
}

input IdentityCardFilterInput {
  and: [IdentityCardFilterInput!]
  backImage: StringOperationFilterInput
  dateOfBirth: DateTimeOperationFilterInput
  frontImage: StringOperationFilterInput
  fullName: StringOperationFilterInput
  gender: UserGenderOperationFilterInput
  nationality: StringOperationFilterInput
  number: StringOperationFilterInput
  or: [IdentityCardFilterInput!]
  placeOfOrigin: StringOperationFilterInput
  placeOfResidence: AddressFilterInput
  validUntil: DateTimeOperationFilterInput
}

input IdentityCardInput {
  backImage: String
  dateOfBirth: DateTime!
  frontImage: String
  fullName: String!
  gender: UserGender!
  nationality: String!
  number: String!
  placeOfOrigin: String!
  placeOfResidence: AddressInput!
  validUntil: DateTime
}

input IdentityCardSortInput {
  backImage: SortEnumType
  dateOfBirth: SortEnumType
  frontImage: SortEnumType
  fullName: SortEnumType
  gender: SortEnumType
  nationality: SortEnumType
  number: SortEnumType
  placeOfOrigin: SortEnumType
  placeOfResidence: AddressSortInput
  validUntil: SortEnumType
}

enum ImageTag {
  USERS_PROFILE
}

input IntOperationFilterInput {
  eq: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  neq: Int
  ngt: Int
  ngte: Int
  nin: [Int]
  nlt: Int
  nlte: Int
}

type Invoice {
  amount: Decimal!
  country: String!
  currency: String!
  email: String!
  from: String!
  fullName: String!
  id: String!
  oneOffSnapshot: OneOffSnapshot
  originContext: String
  paidAt: DateTime!
  subscriptionSnapshot: SubscriptionSnapshot
  to: String!
  transaction: PaymentTransaction
  transactionId: String!
  user: User
  userId: String!
}

input InvoiceFilterInput {
  amount: DecimalOperationFilterInput
  and: [InvoiceFilterInput!]
  country: StringOperationFilterInput
  currency: StringOperationFilterInput
  email: StringOperationFilterInput
  from: StringOperationFilterInput
  fullName: StringOperationFilterInput
  id: StringOperationFilterInput
  oneOffSnapshot: OneOffSnapshotFilterInput
  or: [InvoiceFilterInput!]
  originContext: StringOperationFilterInput
  paidAt: DateTimeOperationFilterInput
  subscriptionSnapshot: SubscriptionSnapshotFilterInput
  to: StringOperationFilterInput
  transactionId: StringOperationFilterInput
  userId: StringOperationFilterInput
}

input InvoiceSortInput {
  amount: SortEnumType
  country: SortEnumType
  currency: SortEnumType
  email: SortEnumType
  from: SortEnumType
  fullName: SortEnumType
  id: SortEnumType
  oneOffSnapshot: OneOffSnapshotSortInput
  originContext: SortEnumType
  paidAt: SortEnumType
  subscriptionSnapshot: SubscriptionSnapshotSortInput
  to: SortEnumType
  transactionId: SortEnumType
  userId: SortEnumType
}

"""A segment of a collection."""
type InvoicesCollectionSegment {
  """A flattened list of the items."""
  items: [Invoice!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

enum KeyTag {
  DELETE
}

input KeyValuePairOfStringAndStringInput {
  key: String!
  value: String!
}

type LegalDocument {
  createdAt: DateTime!
  documentType: DocumentType!
  documentUrl: String!
  name: String!
  note: String!
  updatedAt: DateTime
}

input LegalDocumentFilterInput {
  and: [LegalDocumentFilterInput!]
  createdAt: DateTimeOperationFilterInput
  documentType: DocumentTypeOperationFilterInput
  documentUrl: StringOperationFilterInput
  name: StringOperationFilterInput
  note: StringOperationFilterInput
  or: [LegalDocumentFilterInput!]
  updatedAt: DateTimeOperationFilterInput
}

"""A segment of a collection."""
type LegalPoliciesCollectionSegment {
  """A flattened list of the items."""
  items: [LegalPolicy!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type LegalPolicy {
  content: String!
  createdAt: DateTime!
  effectiveAt: DateTime!
  id: String!
  name: String!
  status: PolicyStatus!
  updatedAt: DateTime
  version: Long!
}

input LegalPolicyFilterInput {
  and: [LegalPolicyFilterInput!]
  content: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  effectiveAt: DateTimeOperationFilterInput
  id: StringOperationFilterInput
  name: StringOperationFilterInput
  or: [LegalPolicyFilterInput!]
  status: PolicyStatusOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  version: LongOperationFilterInput
}

input LegalPolicySortInput {
  content: SortEnumType
  createdAt: SortEnumType
  effectiveAt: SortEnumType
  id: SortEnumType
  name: SortEnumType
  status: SortEnumType
  updatedAt: SortEnumType
  version: SortEnumType
}

input ListByteOperationFilterInput {
  all: ByteOperationFilterInput
  any: Boolean
  none: ByteOperationFilterInput
  some: ByteOperationFilterInput
}

input ListFilterInputTypeOfArtistMemberFilterInput {
  all: ArtistMemberFilterInput
  any: Boolean
  none: ArtistMemberFilterInput
  some: ArtistMemberFilterInput
}

input ListFilterInputTypeOfEntitlementRoleDefaultFilterInput {
  all: EntitlementRoleDefaultFilterInput
  any: Boolean
  none: EntitlementRoleDefaultFilterInput
  some: EntitlementRoleDefaultFilterInput
}

input ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput {
  all: EntitlementSubscriptionOverrideFilterInput
  any: Boolean
  none: EntitlementSubscriptionOverrideFilterInput
  some: EntitlementSubscriptionOverrideFilterInput
}

input ListFilterInputTypeOfLegalDocumentFilterInput {
  all: LegalDocumentFilterInput
  any: Boolean
  none: LegalDocumentFilterInput
  some: LegalDocumentFilterInput
}

input ListFilterInputTypeOfMetadataFilterInput {
  all: MetadataFilterInput
  any: Boolean
  none: MetadataFilterInput
  some: MetadataFilterInput
}

input ListFilterInputTypeOfPlaylistTracksInfoFilterInput {
  all: PlaylistTracksInfoFilterInput
  any: Boolean
  none: PlaylistTracksInfoFilterInput
  some: PlaylistTracksInfoFilterInput
}

input ListFilterInputTypeOfRecordingSplitFilterInput {
  all: RecordingSplitFilterInput
  any: Boolean
  none: RecordingSplitFilterInput
  some: RecordingSplitFilterInput
}

input ListFilterInputTypeOfRoyaltySplitFilterInput {
  all: RoyaltySplitFilterInput
  any: Boolean
  none: RoyaltySplitFilterInput
  some: RoyaltySplitFilterInput
}

input ListFilterInputTypeOfSubscriptionPlanPriceFilterInput {
  all: SubscriptionPlanPriceFilterInput
  any: Boolean
  none: SubscriptionPlanPriceFilterInput
  some: SubscriptionPlanPriceFilterInput
}

input ListFilterInputTypeOfSyncedLineFilterInput {
  all: SyncedLineFilterInput
  any: Boolean
  none: SyncedLineFilterInput
  some: SyncedLineFilterInput
}

input ListFilterInputTypeOfWorkSplitFilterInput {
  all: WorkSplitFilterInput
  any: Boolean
  none: WorkSplitFilterInput
  some: WorkSplitFilterInput
}

input ListFloatOperationFilterInput {
  all: FloatOperationFilterInput
  any: Boolean
  none: FloatOperationFilterInput
  some: FloatOperationFilterInput
}

input ListListByteOperationFilterInput {
  all: ListByteOperationFilterInput
  any: Boolean
  none: ListByteOperationFilterInput
  some: ListByteOperationFilterInput
}

input ListOfUInt32FilterInput {
  and: [ListOfUInt32FilterInput!]
  capacity: IntOperationFilterInput
  count: IntOperationFilterInput
  or: [ListOfUInt32FilterInput!]
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput
  any: Boolean
  none: StringOperationFilterInput
  some: StringOperationFilterInput
}

type Listener {
  avatarImage: String
  bannerImage: String
  createdAt: DateTime!
  displayName: String!
  email: String!
  followerCount: Long!
  followingCount: Long!
  followingUser: [User!]!
  id: String!
  isVerified: Boolean!
  lastFollowers: [String!]!
  lastFollowing: [String!]!
  restriction: Restriction!
  updatedAt: DateTime
  user: User
  userId: String!
  verifiedAt: DateTime
}

input ListenerFilterInput {
  and: [ListenerFilterInput!]
  avatarImage: StringOperationFilterInput
  bannerImage: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  displayName: StringOperationFilterInput
  email: StringOperationFilterInput
  followerCount: LongOperationFilterInput
  followingCount: LongOperationFilterInput
  id: StringOperationFilterInput
  isVerified: BooleanOperationFilterInput
  lastFollowers: ListStringOperationFilterInput
  lastFollowing: ListStringOperationFilterInput
  or: [ListenerFilterInput!]
  restriction: RestrictionFilterInput
  updatedAt: DateTimeOperationFilterInput
  userId: StringOperationFilterInput
  verifiedAt: DateTimeOperationFilterInput
}

input ListenerSortInput {
  avatarImage: SortEnumType
  bannerImage: SortEnumType
  createdAt: SortEnumType
  displayName: SortEnumType
  email: SortEnumType
  followerCount: SortEnumType
  followingCount: SortEnumType
  id: SortEnumType
  isVerified: SortEnumType
  restriction: RestrictionSortInput
  updatedAt: SortEnumType
  userId: SortEnumType
  verifiedAt: SortEnumType
}

"""A segment of a collection."""
type ListenersCollectionSegment {
  """A flattened list of the items."""
  items: [Listener!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

"""
The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

input LongOperationFilterInput {
  eq: Long
  gt: Long
  gte: Long
  in: [Long]
  lt: Long
  lte: Long
  neq: Long
  ngt: Long
  ngte: Long
  nin: [Long]
  nlt: Long
  nlte: Long
}

type Message {
  conversationId: String!
  deletedFor: [String!]!
  id: String!
  isRead: Boolean!
  receiverId: String!
  senderId: String!
  sentAt: DateTime!
  text: String!
}

type Metadata {
  key: String!
  value: String!
}

input MetadataFilterInput {
  and: [MetadataFilterInput!]
  key: StringOperationFilterInput
  or: [MetadataFilterInput!]
  value: StringOperationFilterInput
}

input MetadataInput {
  key: String!
  value: String!
}

type MomoPaymentResponse {
  amount: Long
  localMessage: String
  message: String
  orderId: String
  partnerCode: String
  payUrl: String
  requestId: String
  responseTime: Long
  resultCode: Int
}

type MonthlyStreamCount {
  createdAt: DateTime!
  id: String!
  month: Int!
  processedAt: DateTime
  streamCount: Long!
  track: Track
  trackId: String!
  year: Int!
}

input MonthlyStreamCountFilterInput {
  and: [MonthlyStreamCountFilterInput!]
  createdAt: DateTimeOperationFilterInput
  id: StringOperationFilterInput
  month: IntOperationFilterInput
  or: [MonthlyStreamCountFilterInput!]
  processedAt: DateTimeOperationFilterInput
  streamCount: LongOperationFilterInput
  trackId: StringOperationFilterInput
  year: IntOperationFilterInput
}

input MonthlyStreamCountSortInput {
  createdAt: SortEnumType
  id: SortEnumType
  month: SortEnumType
  processedAt: SortEnumType
  streamCount: SortEnumType
  trackId: SortEnumType
  year: SortEnumType
}

"""A segment of a collection."""
type MonthlyStreamCountsCollectionSegment {
  """A flattened list of the items."""
  items: [MonthlyStreamCount!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

enum MoodType {
  ANGRY
  CALM
  CHILL
  DARK
  ENERGETIC
  HAPPY
  RELAXED
  ROMANTIC
  SAD
}

type MutationInitialization {
  approveArtistPackage(updateStatusRequest: UpdateStatusArtistPackageRequestInput!): Boolean!
  approveArtistRegistration(request: ArtistRegistrationApprovalRequestInput!): Boolean!
  approveTrackUploadRequest(recordingId: String!, trackId: String!, workId: String!): Boolean!
  banUser(targetUserId: String!): Boolean!
  changeArtistPackageStatus(updateStatusRequest: UpdateStatusArtistPackageRequestInput!): Boolean!
  commentReplies(request: CommentRepliesRequestInput!): CommentRepliesResponse!
  commentThread(request: CommentThreadRequestInput!): [TrackCommentResponse!]!
  convertToHls(file: Upload!): String!
  convertToWavFile(file: Upload!): WavFileResponse!
  createAdmin(createAdminRequest: CreateAdminRequestInput!): Boolean!
  createArtistPackage(createRequest: CreateArtistPackageRequestInput!): Boolean!
  createBillingPortalConfiguration(createBillingPortalConfigurationRequest: CreateBillingPortalConfigurationRequestInput!): Boolean!
  createCategory(categoryRequest: CreateCategoryRequestInput!): Boolean!
  createCoupon(createCouponRequest: CreateCouponRequestInput!): Boolean!
  createCustomerPortalSession(returnUrl: String!, version: Long!): String!
  """Create a test entitlement for demonstration purposes."""
  createEntilement(featureValueType: EntitlementValueType!, value: EntitlementValue): Boolean!
  createEntitlement(createEntitlementRequest: CreateEntitlementRequestInput!): Boolean!
  createExpressConnectedAccount: AccountLinkResponse!
  createLegalPolicy(createLegalPolicyRequest: CreateLegalPolicyRequestInput!): Boolean!
  createModerator(createModeratorRequest: CreateModeratorRequestInput!): Boolean!
  createMomoPaymentQR(createMomoPaymentRequest: CreateMomoPaymentRequestInput!): MomoPaymentResponse!
  createMomoPaymentVisa(createMomoPaymentRequest: CreateMomoPaymentRequestInput!): MomoPaymentResponse!
  createPaymentCheckoutSession(createPaymentCheckoutSessionRequest: CreatePaymentCheckoutSessionRequestInput!): CheckoutSessionResponse!
  createRequest(request: RequestCreatingRequestInput!): Boolean!
  createRoyaltyPolicy(createRoyalPolicyRequest: CreateRoyalPolicyRequestInput!): Boolean!
  createSubscription(createSubscriptionRequest: CreateSubscriptionRequestInput!): Boolean!
  createSubscriptionCheckoutSession(createCheckoutSessionRequest: CreateSubscriptionCheckoutSessionRequestInput!): CheckoutSessionResponse!
  createSubscriptionPlan(createSubScriptionPlanRequest: CreateSubScriptionPlanRequestInput!): Boolean!
  createTrackComment(request: CreateTrackCommentRequestInput!): Boolean!
  deactiveEntitlement(code: String!): Boolean!
  deleteCoupon(couponIds: [String!]!): Boolean!
  deleteTrackComment(request: DeleteTrackCommentRequestInput!): Boolean!
  deprecateCoupon(couponIds: [String!]!): Boolean!
  deprecateSubscription(subscriptionId: String!): Boolean!
  downgradeRoyaltyPolicyVersion(version: Long): Boolean!
  entitlementUserCount(code: String!): Long!
  followUser(request: FollowUserRequestInput!): Boolean!
  hello: String!
  reActiveUser(targetUserId: String!): Boolean!
  reactiveEntitlement(code: String!): Boolean!
  registerArtistManual(createArtistRequest: CreateArtistRequestInput!): Boolean!
  rejectArtistRegistration(request: ArtistRegistrationApprovalRequestInput!): Boolean!
  rejectTrackUploadRequest(recordingId: String!, trackId: String!, workId: String!): Boolean!
  seedEntitlements(password: String!): Boolean!
  seedRoyaltyPolicyData(password: String!): Boolean!
  threadedComments(request: ThreadedCommentsRequestInput!): ThreadedCommentsResponse!
  unfollowUser(request: UnfollowUserRequestInput!): Boolean!
  updateProfile(updateArtistRequest: UpdateArtistRequestInput!, updateListenerRequest: UpdateListenerRequestInput!): Boolean!
  updateRequest(request: RequestUpdatingRequestInput!): Boolean!
  updateTrackComment(request: UpdateTrackCommentRequestInput!): Boolean!
  uploadFile(file: Upload!, fileName: String!): String!
  uploadTrack(createRecordingRequest: CreateRecordingRequestInput!, createTrackRequest: CreateTrackRequestInput!, createWorkRequest: CreateWorkRequestInput!, file: Upload!): Boolean!
  uploadTrackFingerprint(artistId: String!, file: Upload!, trackId: String!, trackName: String!): String!
}

type OneOffSnapshot {
  description: String
  estimateDeliveryDays: Int!
  packageAmount: Decimal!
  packageCurrency: CurrencyType!
  packageName: String!
  status: ArtistPackageStatus!
}

input OneOffSnapshotFilterInput {
  and: [OneOffSnapshotFilterInput!]
  description: StringOperationFilterInput
  estimateDeliveryDays: IntOperationFilterInput
  or: [OneOffSnapshotFilterInput!]
  packageAmount: DecimalOperationFilterInput
  packageCurrency: CurrencyTypeOperationFilterInput
  packageName: StringOperationFilterInput
  status: ArtistPackageStatusOperationFilterInput
}

input OneOffSnapshotSortInput {
  description: SortEnumType
  estimateDeliveryDays: SortEnumType
  packageAmount: SortEnumType
  packageCurrency: SortEnumType
  packageName: SortEnumType
  status: SortEnumType
}

enum PathTag {
  API
  BASE
  BIN
  PRIVATE_KEYS
  TOOLS
}

enum PaymentMethodType {
  CARD
  LINK
}

enum PaymentStatus {
  PAID
  PENDING
  UNPAID
}

input PaymentStatusOperationFilterInput {
  eq: PaymentStatus
  in: [PaymentStatus!]
  neq: PaymentStatus
  nin: [PaymentStatus!]
}

type PaymentTransaction {
  amount: Decimal!
  createdAt: DateTime!
  currency: String!
  id: String!
  paymentStatus: PaymentStatus!
  status: TransactionStatus!
  stripeCheckoutSessionId: String!
  stripePaymentId: String
  stripePaymentMethod: [String!]!
  updatedAt: DateTime
  user: User
  userId: String!
}

input PaymentTransactionFilterInput {
  amount: DecimalOperationFilterInput
  and: [PaymentTransactionFilterInput!]
  createdAt: DateTimeOperationFilterInput
  currency: StringOperationFilterInput
  id: StringOperationFilterInput
  or: [PaymentTransactionFilterInput!]
  paymentStatus: PaymentStatusOperationFilterInput
  status: TransactionStatusOperationFilterInput
  stripeCheckoutSessionId: StringOperationFilterInput
  stripePaymentId: StringOperationFilterInput
  stripePaymentMethod: ListStringOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  userId: StringOperationFilterInput
}

input PaymentTransactionSortInput {
  amount: SortEnumType
  createdAt: SortEnumType
  currency: SortEnumType
  id: SortEnumType
  paymentStatus: SortEnumType
  status: SortEnumType
  stripeCheckoutSessionId: SortEnumType
  stripePaymentId: SortEnumType
  updatedAt: SortEnumType
  userId: SortEnumType
}

type PendingArtistRegistrationResponse {
  artistType: ArtistType!
  avatarImage: String
  backImageUrl: String
  birthDate: DateTime!
  email: String!
  frontImageUrl: String
  fullName: String!
  gender: UserGender!
  id: String!
  identityCardDateOfBirth: DateTime!
  identityCardFullName: String!
  identityCardNumber: String!
  members: [ArtistMember!]!
  phoneNumber: String!
  placeOfOrigin: String!
  placeOfResidence: String!
  requestedAt: DateTime!
  stageName: String!
  timeToLive: TimeSpan
}

input PendingArtistRegistrationResponseFilterInput {
  and: [PendingArtistRegistrationResponseFilterInput!]
  artistType: ArtistTypeOperationFilterInput
  avatarImage: StringOperationFilterInput
  backImageUrl: StringOperationFilterInput
  birthDate: DateTimeOperationFilterInput
  email: StringOperationFilterInput
  frontImageUrl: StringOperationFilterInput
  fullName: StringOperationFilterInput
  gender: UserGenderOperationFilterInput
  id: StringOperationFilterInput
  identityCardDateOfBirth: DateTimeOperationFilterInput
  identityCardFullName: StringOperationFilterInput
  identityCardNumber: StringOperationFilterInput
  members: ListFilterInputTypeOfArtistMemberFilterInput
  or: [PendingArtistRegistrationResponseFilterInput!]
  phoneNumber: StringOperationFilterInput
  placeOfOrigin: StringOperationFilterInput
  placeOfResidence: StringOperationFilterInput
  requestedAt: DateTimeOperationFilterInput
  stageName: StringOperationFilterInput
  timeToLive: TimeSpanOperationFilterInput
}

"""A segment of a collection."""
type PendingTrackUploadRequestsCollectionSegment {
  """A flattened list of the items."""
  items: [TrackTempRequest!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

enum PeriodTime {
  DAY
  MONTH
  WEEK
  YEAR
}

input PeriodTimeOperationFilterInput {
  eq: PeriodTime
  in: [PeriodTime!]
  neq: PeriodTime
  nin: [PeriodTime!]
}

type Playlist {
  coverImage: String
  createdAt: DateTime!
  description: String
  id: String!
  isPublic: Boolean!
  name: String!
  tracks: [Track]!
  tracksInfo: [PlaylistTracksInfo!]!
  updatedAt: DateTime
  user: User
  userId: String!
}

input PlaylistFilterInput {
  and: [PlaylistFilterInput!]
  coverImage: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  description: StringOperationFilterInput
  id: StringOperationFilterInput
  isPublic: BooleanOperationFilterInput
  name: StringOperationFilterInput
  or: [PlaylistFilterInput!]
  tracksInfo: ListFilterInputTypeOfPlaylistTracksInfoFilterInput
  updatedAt: DateTimeOperationFilterInput
  userId: StringOperationFilterInput
}

input PlaylistSortInput {
  coverImage: SortEnumType
  createdAt: SortEnumType
  description: SortEnumType
  id: SortEnumType
  isPublic: SortEnumType
  name: SortEnumType
  updatedAt: SortEnumType
  userId: SortEnumType
}

type PlaylistTracksInfo {
  addedTime: DateTime!
  trackId: String!
}

input PlaylistTracksInfoFilterInput {
  addedTime: DateTimeOperationFilterInput
  and: [PlaylistTracksInfoFilterInput!]
  or: [PlaylistTracksInfoFilterInput!]
  trackId: StringOperationFilterInput
}

"""A segment of a collection."""
type PlaylistsCollectionSegment {
  """A flattened list of the items."""
  items: [Playlist!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

enum PolicyStatus {
  ACTIVE
  INACTIVE
  PENDING
}

input PolicyStatusOperationFilterInput {
  eq: PolicyStatus
  in: [PolicyStatus!]
  neq: PolicyStatus
  nin: [PolicyStatus!]
}

enum PolicyType {
  COOKIE
  PRIVACY
  ROYALTY
  TERMS
}

type QueryAudioFingerprintResponse {
  artistId: String!
  artistName: String!
  mediaType: String!
  minConfidence: Float!
  minCoverage: Float!
  queryCoverage: Float!
  queryCoverageLength: Float!
  queryMatchEndsAt: Float!
  queryMatchStartsAt: Float!
  trackCoverage: Float!
  trackCoverageLength: Float!
  trackId: String!
  trackMatchEndsAt: Float!
  trackMatchStartsAt: Float!
  trackName: String!
}

type QueryInitialization {
  artistPackages(order: [ArtistPackageSortInput!], skip: Int, take: Int, where: ArtistPackageFilterInput): ArtistPackagesCollectionSegment
  artists(order: [ArtistSortInput!], skip: Int, take: Int, where: ArtistFilterInput): ArtistsCollectionSegment
  categories(order: [CategorySortInput!], skip: Int, take: Int, where: CategoryFilterInput): CategoriesCollectionSegment
  commentDepth(commentId: String!): Int!
  commentReplies(request: CommentRepliesRequestInput!): CommentRepliesResponse!
  commentThread(request: CommentThreadRequestInput!, skip: Int, take: Int): CommentThreadCollectionSegment
  coupons(order: [CouponSortInput!], skip: Int, take: Int, where: CouponFilterInput): CouponsCollectionSegment
  entitlements(order: [EntitlementSortInput!], skip: Int, take: Int, where: EntitlementFilterInput): [Entitlement!]!
  hello: String!
  invoices(order: [InvoiceSortInput!], skip: Int, take: Int, where: InvoiceFilterInput): InvoicesCollectionSegment
  isCommentInThread(commentId: String!, threadRootId: String!): Boolean!
  legalPolicies(order: [LegalPolicySortInput!], skip: Int, take: Int, where: LegalPolicyFilterInput): LegalPoliciesCollectionSegment
  listeners(order: [ListenerSortInput!], skip: Int, take: Int, where: ListenerFilterInput): ListenersCollectionSegment
  messagesExecutable: [Message!]!
  metadataRecordingUploadRequest(recordingId: String!): RecordingTempRequest!
  metadataTrackUploadRequest(trackId: String!): TrackTempRequest!
  metadataWorkUploadRequest(workId: String!): WorkTempRequest!
  monthlyStreamCounts(order: [MonthlyStreamCountSortInput!], skip: Int, take: Int, where: MonthlyStreamCountFilterInput): MonthlyStreamCountsCollectionSegment
  originalFileTrackUploadRequest(trackId: String!): String!
  pendingArtistRegistrations(pageNumber: Int! = 1, pageSize: Int! = 20, where: PendingArtistRegistrationResponseFilterInput): [PendingArtistRegistrationResponse!]!
  pendingTrackUploadRequests(skip: Int, take: Int, where: TrackTempRequestFilterInput): PendingTrackUploadRequestsCollectionSegment
  playlists(order: [PlaylistSortInput!], skip: Int, take: Int, where: PlaylistFilterInput): PlaylistsCollectionSegment
  queryTrack(file: Upload!): QueryAudioFingerprintResponse!
  queryTracks(file: Upload!): [QueryAudioFingerprintResponse!]!
  recordingsQueryable(order: [RecordingSortInput!], skip: Int, take: Int, where: RecordingFilterInput): RecordingsQueryableCollectionSegment
  requests: [RequestHub!]!
  royaltyPolicies(order: [RoyaltyPolicySortInput!], skip: Int, take: Int, where: RoyaltyPolicyFilterInput): RoyaltyPoliciesCollectionSegment
  royaltyReports(order: [RoyaltyReportSortInput!], skip: Int, take: Int, where: RoyaltyReportFilterInput): RoyaltyReportsCollectionSegment
  subscriptionPlans(order: [SubscriptionPlanSortInput!], skip: Int, take: Int, where: SubscriptionPlanFilterInput): SubscriptionPlansCollectionSegment
  subscriptions(order: [SubscriptionSortInput!], skip: Int, take: Int, where: SubscriptionFilterInput): SubscriptionsCollectionSegment
  threadedComments(request: ThreadedCommentsRequestInput!): ThreadedCommentsResponse!
  trackBySemanticSearch(term: String!): [Track!]!
  trackComments(order: [TrackCommentSortInput!], skip: Int, take: Int, where: TrackCommentFilterInput): TrackCommentsCollectionSegment
  tracks(order: [TrackSortInput!], skip: Int, take: Int, where: TrackFilterInput): TracksCollectionSegment
  transactions(order: [PaymentTransactionSortInput!], skip: Int, take: Int, where: PaymentTransactionFilterInput): TransactionsCollectionSegment
  userSubscriptions(order: [UserSubscriptionSortInput!], skip: Int, take: Int, where: UserSubscriptionFilterInput): UserSubscriptionsCollectionSegment
  users(order: [UserSortInput!], skip: Int, take: Int, where: UserFilterInput): UsersCollectionSegment
  worksQueryable(order: [WorkSortInput!], skip: Int, take: Int, where: WorkFilterInput): WorksQueryableCollectionSegment
}

type Recording {
  createdAt: DateTime!
  description: String
  id: String!
  recordingSplits: [RecordingSplit!]!
  status: RecordingStatus!
  track: Track
  trackId: String!
  users: [User]!
  version: Long!
}

input RecordingFilterInput {
  and: [RecordingFilterInput!]
  createdAt: DateTimeOperationFilterInput
  description: StringOperationFilterInput
  id: StringOperationFilterInput
  or: [RecordingFilterInput!]
  recordingSplits: ListFilterInputTypeOfRecordingSplitFilterInput
  status: RecordingStatusOperationFilterInput
  trackId: StringOperationFilterInput
  version: LongOperationFilterInput
}

input RecordingSortInput {
  createdAt: SortEnumType
  description: SortEnumType
  id: SortEnumType
  status: SortEnumType
  trackId: SortEnumType
  version: SortEnumType
}

type RecordingSplit {
  artistRole: ArtistRole!
  percentage: Decimal!
  userId: String!
}

input RecordingSplitFilterInput {
  and: [RecordingSplitFilterInput!]
  artistRole: ArtistRoleOperationFilterInput
  or: [RecordingSplitFilterInput!]
  percentage: DecimalOperationFilterInput
  userId: StringOperationFilterInput
}

enum RecordingStatus {
  ACTIVE
  INACTIVE
  PENDING
}

input RecordingStatusOperationFilterInput {
  eq: RecordingStatus
  in: [RecordingStatus!]
  neq: RecordingStatus
  nin: [RecordingStatus!]
}

type RecordingTempRequest {
  description: String
  id: String!
  recordingSplitRequests: [CreateRecordingSplitRequest!]!
}

"""A segment of a collection."""
type RecordingsQueryableCollectionSegment {
  """A flattened list of the items."""
  items: [Recording!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type ReleaseInfo {
  isReleased: Boolean!
  releaseDate: DateTime
  releaseStatus: ReleaseStatus!
  releasedAt: DateTime
}

input ReleaseInfoFilterInput {
  and: [ReleaseInfoFilterInput!]
  isReleased: BooleanOperationFilterInput
  or: [ReleaseInfoFilterInput!]
  releaseDate: DateTimeOperationFilterInput
  releaseStatus: ReleaseStatusOperationFilterInput
  releasedAt: DateTimeOperationFilterInput
}

input ReleaseInfoSortInput {
  isReleased: SortEnumType
  releaseDate: SortEnumType
  releaseStatus: SortEnumType
  releasedAt: SortEnumType
}

enum ReleaseStatus {
  CANCELED
  DELAYED
  LEAKED
  NOT_ANNOUNCED
  OFFICIAL
}

input ReleaseStatusOperationFilterInput {
  eq: ReleaseStatus
  in: [ReleaseStatus!]
  neq: ReleaseStatus
  nin: [ReleaseStatus!]
}

input RequestCreatingRequestInput {
  attachments: [String!]
  description: String!
  title: String!
}

type RequestHub {
  attachments: [String!]
  createdAt: DateTime!
  description: String!
  id: String!
  isClosed: Boolean!
  isDeleted: Boolean!
  title: String!
}

input RequestUpdatingRequestInput {
  attachments: [String!]
  description: String
  id: String!
  isClosed: Boolean
  isDeleted: Boolean
  title: String
}

type Restriction {
  expired: DateTime
  reason: String
  restrictedAt: DateTime
  type: RestrictionType!
}

input RestrictionFilterInput {
  and: [RestrictionFilterInput!]
  expired: DateTimeOperationFilterInput
  or: [RestrictionFilterInput!]
  reason: StringOperationFilterInput
  restrictedAt: DateTimeOperationFilterInput
  type: RestrictionTypeOperationFilterInput
}

input RestrictionSortInput {
  expired: SortEnumType
  reason: SortEnumType
  restrictedAt: SortEnumType
  type: SortEnumType
}

enum RestrictionType {
  BANNED
  NONE
  SUSPENDED
}

input RestrictionTypeOperationFilterInput {
  eq: RestrictionType
  in: [RestrictionType!]
  neq: RestrictionType
  nin: [RestrictionType!]
}

"""A segment of a collection."""
type RoyaltyPoliciesCollectionSegment {
  """A flattened list of the items."""
  items: [RoyaltyPolicy!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type RoyaltyPolicy {
  createdAt: DateTime!
  currency: CurrencyType!
  effectiveAt: DateTime!
  id: String!
  ratePerStream: Decimal!
  recordingPercentage: Decimal!
  status: PolicyStatus!
  updatedAt: DateTime
  version: Long!
  workPercentage: Decimal!
}

input RoyaltyPolicyFilterInput {
  and: [RoyaltyPolicyFilterInput!]
  createdAt: DateTimeOperationFilterInput
  currency: CurrencyTypeOperationFilterInput
  effectiveAt: DateTimeOperationFilterInput
  id: StringOperationFilterInput
  or: [RoyaltyPolicyFilterInput!]
  ratePerStream: DecimalOperationFilterInput
  recordingPercentage: DecimalOperationFilterInput
  status: PolicyStatusOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  version: LongOperationFilterInput
  workPercentage: DecimalOperationFilterInput
}

input RoyaltyPolicySortInput {
  createdAt: SortEnumType
  currency: SortEnumType
  effectiveAt: SortEnumType
  id: SortEnumType
  ratePerStream: SortEnumType
  recordingPercentage: SortEnumType
  status: SortEnumType
  updatedAt: SortEnumType
  version: SortEnumType
  workPercentage: SortEnumType
}

type RoyaltyReport {
  createdAt: DateTime!
  id: String!
  month: Int!
  royaltySplits: [RoyaltySplit!]!
  streamCount: Long!
  totalRoyaltyAmount: Decimal!
  track: Track
  trackId: String!
  users: [User]!
  year: Int!
}

input RoyaltyReportFilterInput {
  and: [RoyaltyReportFilterInput!]
  createdAt: DateTimeOperationFilterInput
  id: StringOperationFilterInput
  month: IntOperationFilterInput
  or: [RoyaltyReportFilterInput!]
  royaltySplits: ListFilterInputTypeOfRoyaltySplitFilterInput
  streamCount: LongOperationFilterInput
  totalRoyaltyAmount: DecimalOperationFilterInput
  trackId: StringOperationFilterInput
  year: IntOperationFilterInput
}

input RoyaltyReportSortInput {
  createdAt: SortEnumType
  id: SortEnumType
  month: SortEnumType
  streamCount: SortEnumType
  totalRoyaltyAmount: SortEnumType
  trackId: SortEnumType
  year: SortEnumType
}

"""A segment of a collection."""
type RoyaltyReportsCollectionSegment {
  """A flattened list of the items."""
  items: [RoyaltyReport!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type RoyaltySplit {
  amount: Decimal!
  artistRole: ArtistRole!
  isTransferred: Boolean!
  level: AggregationLevel!
  percentage: Decimal!
  userId: String!
}

input RoyaltySplitFilterInput {
  amount: DecimalOperationFilterInput
  and: [RoyaltySplitFilterInput!]
  artistRole: ArtistRoleOperationFilterInput
  isTransferred: BooleanOperationFilterInput
  level: AggregationLevelOperationFilterInput
  or: [RoyaltySplitFilterInput!]
  percentage: DecimalOperationFilterInput
  userId: StringOperationFilterInput
}

enum SortEnumType {
  ASC
  DESC
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  contains: String
  endsWith: String
  eq: String
  in: [String]
  ncontains: String
  nendsWith: String
  neq: String
  nin: [String]
  nstartsWith: String
  or: [StringOperationFilterInput!]
  startsWith: String
}

input StripeProductRequestInput {
  id: String!
  stripePriceIds: [String!]!
}

enum StripeSubscriptionCancelMode {
  AT_PERIOD_END
  IMMEDIATELY
}

enum StripeSubscriptionUpdate {
  PRICE
  PROMOTION_CODE
  QUANTITY
}

type Subscription {
  amount: Decimal!
  code: String!
  createdAt: DateTime!
  currency: CurrencyType!
  description: String
  id: String!
  name: String!
  status: SubscriptionStatus!
  tier: SubscriptionTier!
  updatedAt: DateTime
  version: Int!
}

enum SubscriptionCycle {
  LIFETIME
  MONTHLY
  WEEKLY
  YEARLY
}

input SubscriptionFilterInput {
  amount: DecimalOperationFilterInput
  and: [SubscriptionFilterInput!]
  code: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  currency: CurrencyTypeOperationFilterInput
  description: StringOperationFilterInput
  id: StringOperationFilterInput
  name: StringOperationFilterInput
  or: [SubscriptionFilterInput!]
  status: SubscriptionStatusOperationFilterInput
  tier: SubscriptionTierOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  version: IntOperationFilterInput
}

type SubscriptionPlan {
  id: String!
  stripeProductActive: Boolean!
  stripeProductId: String!
  stripeProductImages: [String!]
  stripeProductMetadata: [Metadata!]
  stripeProductName: String!
  stripeProductType: String!
  subscription: Subscription
  subscriptionId: String!
  subscriptionPlanPrices: [SubscriptionPlanPrice!]!
}

input SubscriptionPlanFilterInput {
  and: [SubscriptionPlanFilterInput!]
  id: StringOperationFilterInput
  or: [SubscriptionPlanFilterInput!]
  stripeProductActive: BooleanOperationFilterInput
  stripeProductId: StringOperationFilterInput
  stripeProductImages: ListStringOperationFilterInput
  stripeProductMetadata: ListFilterInputTypeOfMetadataFilterInput
  stripeProductName: StringOperationFilterInput
  stripeProductType: StringOperationFilterInput
  subscriptionId: StringOperationFilterInput
  subscriptionPlanPrices: ListFilterInputTypeOfSubscriptionPlanPriceFilterInput
}

type SubscriptionPlanPrice {
  interval: PeriodTime!
  intervalCount: Long!
  stripePriceActive: Boolean!
  stripePriceCurrency: String!
  stripePriceId: String!
  stripePriceLookupKey: String!
  stripePriceMetadata: [Metadata!]
  stripePriceUnitAmount: Long!
}

input SubscriptionPlanPriceFilterInput {
  and: [SubscriptionPlanPriceFilterInput!]
  interval: PeriodTimeOperationFilterInput
  intervalCount: LongOperationFilterInput
  or: [SubscriptionPlanPriceFilterInput!]
  stripePriceActive: BooleanOperationFilterInput
  stripePriceCurrency: StringOperationFilterInput
  stripePriceId: StringOperationFilterInput
  stripePriceLookupKey: StringOperationFilterInput
  stripePriceMetadata: ListFilterInputTypeOfMetadataFilterInput
  stripePriceUnitAmount: LongOperationFilterInput
}

input SubscriptionPlanSortInput {
  id: SortEnumType
  stripeProductActive: SortEnumType
  stripeProductId: SortEnumType
  stripeProductName: SortEnumType
  stripeProductType: SortEnumType
  subscriptionId: SortEnumType
}

"""A segment of a collection."""
type SubscriptionPlansCollectionSegment {
  """A flattened list of the items."""
  items: [SubscriptionPlan!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type SubscriptionSnapshot {
  stripeProductActive: Boolean!
  stripeProductId: String!
  stripeProductImages: [String!]
  stripeProductMetadata: [Metadata!]
  stripeProductName: String!
  stripeProductType: String!
  subscriptionAmount: Decimal!
  subscriptionCode: String!
  subscriptionCurrency: CurrencyType!
  subscriptionDescription: String
  subscriptionName: String!
  subscriptionPlanPrices: [SubscriptionPlanPrice!]!
  subscriptionStatus: SubscriptionStatus!
  subscriptionTier: SubscriptionTier!
  subscriptionVersion: Int!
}

input SubscriptionSnapshotFilterInput {
  and: [SubscriptionSnapshotFilterInput!]
  or: [SubscriptionSnapshotFilterInput!]
  stripeProductActive: BooleanOperationFilterInput
  stripeProductId: StringOperationFilterInput
  stripeProductImages: ListStringOperationFilterInput
  stripeProductMetadata: ListFilterInputTypeOfMetadataFilterInput
  stripeProductName: StringOperationFilterInput
  stripeProductType: StringOperationFilterInput
  subscriptionAmount: DecimalOperationFilterInput
  subscriptionCode: StringOperationFilterInput
  subscriptionCurrency: CurrencyTypeOperationFilterInput
  subscriptionDescription: StringOperationFilterInput
  subscriptionName: StringOperationFilterInput
  subscriptionPlanPrices: ListFilterInputTypeOfSubscriptionPlanPriceFilterInput
  subscriptionStatus: SubscriptionStatusOperationFilterInput
  subscriptionTier: SubscriptionTierOperationFilterInput
  subscriptionVersion: IntOperationFilterInput
}

input SubscriptionSnapshotSortInput {
  stripeProductActive: SortEnumType
  stripeProductId: SortEnumType
  stripeProductName: SortEnumType
  stripeProductType: SortEnumType
  subscriptionAmount: SortEnumType
  subscriptionCode: SortEnumType
  subscriptionCurrency: SortEnumType
  subscriptionDescription: SortEnumType
  subscriptionName: SortEnumType
  subscriptionStatus: SortEnumType
  subscriptionTier: SortEnumType
  subscriptionVersion: SortEnumType
}

input SubscriptionSortInput {
  amount: SortEnumType
  code: SortEnumType
  createdAt: SortEnumType
  currency: SortEnumType
  description: SortEnumType
  id: SortEnumType
  name: SortEnumType
  status: SortEnumType
  tier: SortEnumType
  updatedAt: SortEnumType
  version: SortEnumType
}

enum SubscriptionStatus {
  ACTIVE
  DEPRECATED
  INACTIVE
}

input SubscriptionStatusOperationFilterInput {
  eq: SubscriptionStatus
  in: [SubscriptionStatus!]
  neq: SubscriptionStatus
  nin: [SubscriptionStatus!]
}

enum SubscriptionTier {
  FREE
  PREMIUM
  PRO
}

input SubscriptionTierOperationFilterInput {
  eq: SubscriptionTier
  in: [SubscriptionTier!]
  neq: SubscriptionTier
  nin: [SubscriptionTier!]
}

"""A segment of a collection."""
type SubscriptionsCollectionSegment {
  """A flattened list of the items."""
  items: [Subscription!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type SyncedLine {
  text: String!
  time: Float!
}

input SyncedLineFilterInput {
  and: [SyncedLineFilterInput!]
  or: [SyncedLineFilterInput!]
  text: StringOperationFilterInput
  time: FloatOperationFilterInput
}

input ThreadedCommentsRequestInput {
  page: Int!
  pageSize: Int!
  sortOrder: CommentSortOrder!
  trackId: String!
}

type ThreadedCommentsResponse {
  hasNextPage: Boolean!
  page: Int!
  pageSize: Int!
  threads: [CommentThread!]!
  totalThreads: Int!
}

"""The `TimeSpan` scalar represents an ISO-8601 compliant duration type."""
scalar TimeSpan

input TimeSpanOperationFilterInput {
  eq: TimeSpan
  gt: TimeSpan
  gte: TimeSpan
  in: [TimeSpan]
  lt: TimeSpan
  lte: TimeSpan
  neq: TimeSpan
  ngt: TimeSpan
  ngte: TimeSpan
  nin: [TimeSpan]
  nlt: TimeSpan
  nlte: TimeSpan
}

type Track {
  alternativeDescription: String!
  artist: [Artist]!
  category: [Category]!
  categoryIds: [String!]!
  coverImage: String!
  createdAt: DateTime!
  createdBy: String!
  description: String
  embeddingVector: [Float!]!
  favoriteCount: Long!
  featuredArtistIds: [String!]!
  id: String!
  isExplicit: Boolean!
  isMonetized: Boolean!
  lyrics: String
  mainArtistIds: [String!]!
  name: String!
  previewVideo: String
  releaseInfo: ReleaseInfo!
  restriction: Restriction!
  streamCount: Long!
  syncedLyrics: [SyncedLine!]!
  tags: [String!]!
  type: TrackType!
  updatedAt: DateTime
  updatedBy: String
}

type TrackComment {
  commenterId: String!
  content: String!
  createdAt: DateTime!
  createdBy: String!
  depth: Int!
  id: String!
  isDeleted: Boolean!
  isEdited: Boolean!
  isRootComment: Boolean!
  parentCommentId: String
  replyCount: Long!
  rootCommentId: String
  sortOrder: Int!
  threadId: String!
  threadPath: [String!]!
  threadUpdatedAt: DateTime!
  totalRepliesCount: Long!
  trackId: String!
  updatedAt: DateTime
  updatedBy: String
}

input TrackCommentFilterInput {
  and: [TrackCommentFilterInput!]
  commenterId: StringOperationFilterInput
  content: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  createdBy: StringOperationFilterInput
  depth: IntOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  isEdited: BooleanOperationFilterInput
  isRootComment: BooleanOperationFilterInput
  or: [TrackCommentFilterInput!]
  parentCommentId: StringOperationFilterInput
  replyCount: LongOperationFilterInput
  rootCommentId: StringOperationFilterInput
  sortOrder: IntOperationFilterInput
  threadPath: ListStringOperationFilterInput
  threadUpdatedAt: DateTimeOperationFilterInput
  totalRepliesCount: LongOperationFilterInput
  trackId: StringOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  updatedBy: StringOperationFilterInput
}

type TrackCommentResponse {
  commenterId: String!
  content: String!
  createdAt: DateTime!
  depth: Int!
  id: String!
  isDeleted: Boolean!
  isEdited: Boolean!
  isRootComment: Boolean!
  parentCommentId: String
  replyCount: Long!
  rootCommentId: String
  threadId: String!
  threadPath: [String!]!
  threadUpdatedAt: DateTime!
  totalRepliesCount: Long!
  trackId: String!
  updatedAt: DateTime
}

input TrackCommentSortInput {
  commenterId: SortEnumType
  content: SortEnumType
  createdAt: SortEnumType
  createdBy: SortEnumType
  depth: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  isEdited: SortEnumType
  isRootComment: SortEnumType
  parentCommentId: SortEnumType
  replyCount: SortEnumType
  rootCommentId: SortEnumType
  sortOrder: SortEnumType
  threadUpdatedAt: SortEnumType
  totalRepliesCount: SortEnumType
  trackId: SortEnumType
  updatedAt: SortEnumType
  updatedBy: SortEnumType
}

"""A segment of a collection."""
type TrackCommentsCollectionSegment {
  """A flattened list of the items."""
  items: [TrackComment!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input TrackFilterInput {
  alternativeDescription: StringOperationFilterInput
  and: [TrackFilterInput!]
  audioFeature: AudioFeatureFilterInput
  audioFingerprint: AudioFingerprintFilterInput
  categoryIds: ListStringOperationFilterInput
  coverImage: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  createdBy: StringOperationFilterInput
  description: StringOperationFilterInput
  embeddingVector: ListFloatOperationFilterInput
  favoriteCount: LongOperationFilterInput
  featuredArtistIds: ListStringOperationFilterInput
  id: StringOperationFilterInput
  isExplicit: BooleanOperationFilterInput
  isMonetized: BooleanOperationFilterInput
  lyrics: StringOperationFilterInput
  mainArtistIds: ListStringOperationFilterInput
  name: StringOperationFilterInput
  or: [TrackFilterInput!]
  previewVideo: StringOperationFilterInput
  releaseInfo: ReleaseInfoFilterInput
  restriction: RestrictionFilterInput
  streamCount: LongOperationFilterInput
  syncedLyrics: ListFilterInputTypeOfSyncedLineFilterInput
  tags: ListStringOperationFilterInput
  type: TrackTypeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  updatedBy: StringOperationFilterInput
}

input TrackSortInput {
  alternativeDescription: SortEnumType
  audioFeature: AudioFeatureSortInput
  audioFingerprint: AudioFingerprintSortInput
  coverImage: SortEnumType
  createdAt: SortEnumType
  createdBy: SortEnumType
  description: SortEnumType
  favoriteCount: SortEnumType
  id: SortEnumType
  isExplicit: SortEnumType
  isMonetized: SortEnumType
  lyrics: SortEnumType
  name: SortEnumType
  previewVideo: SortEnumType
  releaseInfo: ReleaseInfoSortInput
  restriction: RestrictionSortInput
  streamCount: SortEnumType
  type: SortEnumType
  updatedAt: SortEnumType
  updatedBy: SortEnumType
}

type TrackTempRequest {
  categoryIds: [String!]!
  coverImage: String!
  createdBy: String!
  description: String
  featuredArtistIds: [String!]!
  id: String!
  isExplicit: Boolean!
  lyrics: String
  mainArtistIds: [String!]!
  name: String!
  previewVideo: String
  releaseInfo: ReleaseInfo!
  requestedAt: DateTime!
  tags: [String!]!
  type: TrackType!
}

input TrackTempRequestFilterInput {
  and: [TrackTempRequestFilterInput!]
  categoryIds: ListStringOperationFilterInput
  coverImage: StringOperationFilterInput
  createdBy: StringOperationFilterInput
  description: StringOperationFilterInput
  featuredArtistIds: ListStringOperationFilterInput
  id: StringOperationFilterInput
  isExplicit: BooleanOperationFilterInput
  lyrics: StringOperationFilterInput
  mainArtistIds: ListStringOperationFilterInput
  name: StringOperationFilterInput
  or: [TrackTempRequestFilterInput!]
  previewVideo: StringOperationFilterInput
  releaseInfo: ReleaseInfoFilterInput
  requestedAt: DateTimeOperationFilterInput
  tags: ListStringOperationFilterInput
  type: TrackTypeOperationFilterInput
}

enum TrackType {
  COVER
  LIVE
  ORIGINAL
  REMIX
  SAMPLE
}

input TrackTypeOperationFilterInput {
  eq: TrackType
  in: [TrackType!]
  neq: TrackType
  nin: [TrackType!]
}

"""A segment of a collection."""
type TracksCollectionSegment {
  """A flattened list of the items."""
  items: [Track!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

enum TransactionStatus {
  COMPLETED
  EXPIRED
  OPEN
}

input TransactionStatusOperationFilterInput {
  eq: TransactionStatus
  in: [TransactionStatus!]
  neq: TransactionStatus
  nin: [TransactionStatus!]
}

"""A segment of a collection."""
type TransactionsCollectionSegment {
  """A flattened list of the items."""
  items: [PaymentTransaction!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

scalar UInt32

input UnfollowUserRequestInput {
  targetUserId: String!
}

input UpdateArtistRequestInput {
  avatarImage: String
  bannerImage: String
  biography: String
  email: String
  fullName: String
  phoneNumber: String
  stageName: String
}

input UpdateEntitlementRequestInput {
  code: String!
  description: String
  expiredAt: DateTime
  name: String
  value: EntitlementValue
  valueType: EntitlementValueType
}

input UpdateListenerRequestInput {
  avatarImage: String
  bannerImage: String
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
}

input UpdateStatusArtistPackageRequestInput {
  id: String!
  status: ArtistPackageStatus!
}

input UpdateTrackCommentRequestInput {
  commentId: String!
  content: String!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  birthDate: DateTime!
  createdAt: DateTime!
  createdBy: String!
  email: String!
  fullName: String!
  gender: UserGender!
  id: String!
  isLinkedWithGoogle: Boolean!
  lastLoginAt: DateTime
  phoneNumber: String
  role: UserRole!
  status: UserStatus!
  stripeAccountId: String
  stripeCustomerId: String
  updatedAt: DateTime
  updatedBy: String
}

input UserFilterInput {
  and: [UserFilterInput!]
  birthDate: DateTimeOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  createdBy: StringOperationFilterInput
  email: StringOperationFilterInput
  fcmToken: StringOperationFilterInput
  fullName: StringOperationFilterInput
  gender: UserGenderOperationFilterInput
  id: StringOperationFilterInput
  isLinkedWithGoogle: BooleanOperationFilterInput
  lastLoginAt: DateTimeOperationFilterInput
  or: [UserFilterInput!]
  passwordHash: StringOperationFilterInput
  phoneNumber: StringOperationFilterInput
  refreshToken: StringOperationFilterInput
  refreshTokenExpiryTime: DateTimeOperationFilterInput
  role: UserRoleOperationFilterInput
  status: UserStatusOperationFilterInput
  stripeAccountId: StringOperationFilterInput
  stripeCustomerId: StringOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  updatedBy: StringOperationFilterInput
}

enum UserGender {
  FEMALE
  MALE
  NOT_SPECIFIED
  OTHER
}

input UserGenderOperationFilterInput {
  eq: UserGender
  in: [UserGender!]
  neq: UserGender
  nin: [UserGender!]
}

enum UserRole {
  ADMIN
  ARTIST
  GUEST
  LISTENER
  MODERATOR
}

input UserRoleOperationFilterInput {
  eq: UserRole
  in: [UserRole!]
  neq: UserRole
  nin: [UserRole!]
}

input UserSortInput {
  birthDate: SortEnumType
  createdAt: SortEnumType
  createdBy: SortEnumType
  email: SortEnumType
  fcmToken: SortEnumType
  fullName: SortEnumType
  gender: SortEnumType
  id: SortEnumType
  isLinkedWithGoogle: SortEnumType
  lastLoginAt: SortEnumType
  passwordHash: SortEnumType
  phoneNumber: SortEnumType
  refreshToken: SortEnumType
  refreshTokenExpiryTime: SortEnumType
  role: SortEnumType
  status: SortEnumType
  stripeAccountId: SortEnumType
  stripeCustomerId: SortEnumType
  updatedAt: SortEnumType
  updatedBy: SortEnumType
}

enum UserStatus {
  ACTIVE
  BANNED
  INACTIVE
}

input UserStatusOperationFilterInput {
  eq: UserStatus
  in: [UserStatus!]
  neq: UserStatus
  nin: [UserStatus!]
}

type UserSubscription {
  autoRenew: Boolean!
  cancelAtEndOfPeriod: Boolean!
  canceledAt: DateTime
  createdAt: DateTime!
  id: String!
  isActive: Boolean!
  periodEnd: DateTime
  periodStart: DateTime!
  subscription: Subscription
  subscriptionId: String!
  updatedAt: DateTime
  user: User
  userId: String!
}

input UserSubscriptionFilterInput {
  and: [UserSubscriptionFilterInput!]
  autoRenew: BooleanOperationFilterInput
  cancelAtEndOfPeriod: BooleanOperationFilterInput
  canceledAt: DateTimeOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  id: StringOperationFilterInput
  isActive: BooleanOperationFilterInput
  or: [UserSubscriptionFilterInput!]
  periodEnd: DateTimeOperationFilterInput
  periodStart: DateTimeOperationFilterInput
  subscriptionId: StringOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  userId: StringOperationFilterInput
}

input UserSubscriptionSortInput {
  autoRenew: SortEnumType
  cancelAtEndOfPeriod: SortEnumType
  canceledAt: SortEnumType
  createdAt: SortEnumType
  id: SortEnumType
  isActive: SortEnumType
  periodEnd: SortEnumType
  periodStart: SortEnumType
  subscriptionId: SortEnumType
  updatedAt: SortEnumType
  userId: SortEnumType
}

"""A segment of a collection."""
type UserSubscriptionsCollectionSegment {
  """A flattened list of the items."""
  items: [UserSubscription!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

"""A segment of a collection."""
type UsersCollectionSegment {
  """A flattened list of the items."""
  items: [User!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type WavFileResponse {
  originalBitrate: Long!
  outputWavPath: String!
}

type Work {
  createdAt: DateTime!
  description: String
  id: String!
  status: WorkStatus!
  track: Track
  trackId: String!
  users: [User]!
  version: Long!
  workSplits: [WorkSplit!]!
}

input WorkFilterInput {
  and: [WorkFilterInput!]
  createdAt: DateTimeOperationFilterInput
  description: StringOperationFilterInput
  id: StringOperationFilterInput
  or: [WorkFilterInput!]
  status: WorkStatusOperationFilterInput
  trackId: StringOperationFilterInput
  version: LongOperationFilterInput
  workSplits: ListFilterInputTypeOfWorkSplitFilterInput
}

input WorkSortInput {
  createdAt: SortEnumType
  description: SortEnumType
  id: SortEnumType
  status: SortEnumType
  trackId: SortEnumType
  version: SortEnumType
}

type WorkSplit {
  artistRole: ArtistRole!
  percentage: Decimal!
  userId: String!
}

input WorkSplitFilterInput {
  and: [WorkSplitFilterInput!]
  artistRole: ArtistRoleOperationFilterInput
  or: [WorkSplitFilterInput!]
  percentage: DecimalOperationFilterInput
  userId: StringOperationFilterInput
}

enum WorkStatus {
  ACTIVE
  INACTIVE
  PENDING
}

input WorkStatusOperationFilterInput {
  eq: WorkStatus
  in: [WorkStatus!]
  neq: WorkStatus
  nin: [WorkStatus!]
}

type WorkTempRequest {
  description: String
  id: String!
  workSplits: [CreateWorkSplitRequest!]!
}

"""A segment of a collection."""
type WorksQueryableCollectionSegment {
  """A flattened list of the items."""
  items: [Work!]
  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}